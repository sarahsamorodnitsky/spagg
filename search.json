[{"path":"https://sarahsamorodnitsky.github.io/spagg/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 spagg authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/articles/lung_analysis.html","id":"weighted-aggregations","dir":"Articles","previous_headings":"","what":"Weighted Aggregations","title":"Applying spagg to a Non-Small Cell Lung Cancer Data","text":"first consider different approaches averaging Ripely’s K across ROIs within tumor sample. Let’s start defining notation. Suppose sample ii RiR_i ROIs. Let nirn_{ir} number cells sample ii ROI rr. Let AirA_{ir} represent area sample ii ROI rr. Let K̂ir\\hat K_{ir} represent spatial distribution CD4+ T cells evaluate radius 3030. spagg contains implementations following three weighted averages: K‾iDiggle=1∑r=1Rinir∑r=1RinirK̂ir\\begin{equation*} \\bar K_i^{Diggle} = \\frac{1}{\\sum_{r=1}^{R_i} n_{ir}} \\sum_{r=1}^{R_i} n_{ir} \\hat K_{ir} \\end{equation*} K‾iBaddeley=1∑r=1Rinir2∑r=1Rinir2K̂ir\\begin{equation*}   \\bar K_i^{Baddeley} = \\frac{1}{\\sum_{r=1}^{R_i} n^2_{ir}} \\sum_{r=1}^{R_i} n^2_{ir} \\hat K_{ir} \\end{equation*} K‾iLandau=∑r=1RiAir∑r=1Rinir∑r=1Rinir2AirK̂ir\\begin{equation*}   \\bar K_i^{Landau} = \\frac{\\sum_{r=1}^{R_i} A_{ir}}{\\sum_{r=1}^{R_i} n_{ir}} \\sum_{r=1}^{R_i} \\frac{n^2_{ir}}{A_{ir}} \\hat K_{ir}  \\end{equation*} K‾iDiggle\\bar K_i^{Diggle} (Diggle, Lange, Beneš (1991)), K‾iBaddeley\\bar K_i^{Baddeley} (Baddeley et al. (1993)), K‾iLandau\\bar K_i^{Landau} (Landau, Rabe-Hesketh, Everall (2004)) proposed approaches aggregating replicated Ripley’s K statistics. Let’s estimate Ripley’s K r=30r=30 ROI. Note may take several seconds (30 seconds) run. Ripley’s K estimates NaNs corresponding image contained 00 11 CD4+ T cell. remove ROIs analysis. can now visualize distribution spatial summaries within image illustration variation spatial distribution CD4+ T cells across ROIs.  , compute weighted averages given . also compute standard arithmetic mean comparison. , visualize spread various spatial aggregation methods within sample. samples, averages yield similar values. others, values show large variation.  now data.frame column corresponding average. Let’s add MHCII-high status variable can association testing. like test spatial arrangement CD4+ T cells associated MHCII-high status. compare significance association across four spatial aggregation methods. find significant associations spatial distribution CD4 T cells estimated Ripley’s K MHCII-high status radius r=30r=30.","code":"# Set the radius r <- 30  # Save the image IDs ids <- unique(lung_df_tumor$id)  # Initialize a data.frame to store the results for each ROI results <- lung_df_tumor %>%    dplyr::select(PID, id) %>%   dplyr::distinct() %>%   dplyr::mutate(spatial = NA,                 npoints = NA,                 area = NA)   # Iterate through the ROIs (this will take a few seconds) for (i in 1:length(ids)) {     # Save the ith image  image.i <- lung_df_tumor %>%    dplyr::filter(id == ids[i]) %>%    dplyr::select(x, y, type)     # Convert to a point process object    w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)    image.i.subset <- image.i %>% dplyr::filter(type == \"CD4+ T cell\")    image.ppp <- spatstat.geom::as.ppp(image.i.subset, W = w)    marks(image.ppp) <- image.i.subset$type     # Compute Kest    Ki <- spatstat.explore::Kest(image.ppp, r = 0:r)       # Calculate the number of points    npoints.i <- spatstat.geom::npoints(image.ppp)        # Calculate the area    area.i <- spatstat.geom::area(image.ppp)       # Save the results    results[results$id == ids[i],]$spatial <- Ki$iso[r+1]    results[results$id == ids[i],]$npoints <- npoints.i    results[results$id == ids[i],]$area <- area.i }  # View the first few rows head(results) #> # A tibble: 6 × 5 #>   PID           id                                  spatial npoints    area #>   <chr>         <chr>                                 <dbl>   <int>   <dbl> #> 1 #01 0-889-121 #01 0-889-121 P44_[40864,18015].im3      0        2 301361. #> 2 #01 0-889-121 #01 0-889-121 P44_[42689,19214].im3  47576.       4 285454. #> 3 #01 0-889-121 #01 0-889-121 P44_[42806,16718].im3      0        3 332974. #> 4 #01 0-889-121 #01 0-889-121 P44_[44311,17766].im3      0        5 333936. #> 5 #01 0-889-121 #01 0-889-121 P44_[45366,16647].im3  27781.       9 333376. #> 6 #02 1-037-393 #02 1-037-393 P44_[56576,16907].im3    NaN        0  52210. # Remove NAs results <- results[!is.na(results$spatial),]  # Visualize the distribution of spatial summaries within each sample results %>%   dplyr::mutate(PID = factor(PID)) %>%   ggplot(aes(x = PID, y = spatial, group = PID)) +    geom_boxplot() +   theme_bw() +    theme(axis.text.x = element_blank(),            axis.ticks.x = element_blank()) +   ggtitle(\"Ripley's K statistics for ROIs within a each sample\") +   ylab(\"Kest\") # Compute averages results_mean <- results %>%     dplyr::group_by(PID) %>%     dplyr::summarise_at(dplyr::vars(spatial),                         list(~mean(.x),                               ~landau.avg(K.vec = .x, area.vec = area, n.vec = npoints),                              ~diggle.avg(K.vec = .x, n.vec = npoints),                              ~baddeley.avg(K.vec = .x, n.vec = npoints)))  # Plot the averages results_mean %>%   tidyr::pivot_longer(2:5, names_to = \"mean\", values_to = \"value\") %>%   dplyr::mutate(mean = recode(mean,                                \"mean\" = \"Arithmetic Mean\",                               \"landau.avg\" = \"Landau Mean\",                               \"diggle.avg\" = \"Diggle Mean\",                               \"baddeley.avg\" = \"Baddeley Mean\")) %>%   ggplot(aes(x = PID, y = value, group = mean, color = mean)) +   geom_point() +   theme_bw() +   theme(axis.text.x = element_blank(),           axis.ticks.x = element_blank()) +   ylab(\"Average Kest\") +   ggtitle(\"Averaged Ripley's K within each sample\") +   scale_color_discrete(name = \"Aggregation Method\") # First, check the ordering matches all(unique(lung_df_tumor$PID) == results_mean$PID) # TRUE! #> [1] TRUE  # Add in MHCII-high status results_mean$mhcII_high <- lung_df_tumor %>%    dplyr::select(PID, mhcII_high) %>%   dplyr::distinct() %>%   dplyr::select(mhcII_high) %>%   unlist()  # Test for an association between CD4 T cell spatial distributions and MHCII-high status mean.glm <- glm(mhcII_high ~ mean, data = results_mean, family = binomial()) diggle.glm <- glm(mhcII_high ~ diggle.avg, data = results_mean, family = binomial()) baddeley.glm <- glm(mhcII_high ~ baddeley.avg, data = results_mean, family = binomial()) landau.glm <- glm(mhcII_high ~ landau.avg, data = results_mean, family = binomial())  # P-values from each approach summary(mean.glm)$coef[2,4] #> [1] 0.2591465 summary(diggle.glm)$coef[2,4] #> [1] 0.3146754 summary(baddeley.glm)$coef[2,4] #> [1] 0.3192316 summary(landau.glm)$coef[2,4] #> [1] 0.3509682"},{"path":"https://sarahsamorodnitsky.github.io/spagg/articles/lung_analysis.html","id":"ensemble-approaches","dir":"Articles","previous_headings":"","what":"Ensemble Approaches","title":"Applying spagg to a Non-Small Cell Lung Cancer Data","text":"now illustrate using ensemble testing test hypothesis. ensemble approaches consider multiple random weights used construct aggregations spatial summary statistics. set random weights, test association weighted aggregation outcome. repeat many random weights combine resulting p-values using p-value combination method. purpose, use Cauchy combination test Liu Xie (2020). motivation behind ensemble approaches best set weights (weights yield highest power) generally unknown outset. reason, considering many different possible weights may gain us power may capture true relationship aggregated spatial summary statistics sample-level outcome. spagg contains implementations three different approaches: Standard ensemble testing: approach, spagg randomly generates weights standard normal distribution used construct weighted mean Ripley’s K estimates obtained ROI. process repeated many times. random set weights, association weighted mean spatial summary sample-level outcomes tested. resulting p-values combined using Cauchy combination test. approach contained ensemble.avg function. Resampling: approach, spagg randomly samples one spatial summary statisti per sample tests association sample-level outcome. process repeated many times resulting p-values combined using Cauchy combination test. approach contained resampling.avg function. Combination testing: approach, spagg randomly generates weights standard normal distribution uses weights well number cells ROI construct weighted mean Ripley’s K estimates. process repeated many times resulting p-values combined using Cauchy combination test. approach contained combo.weight.avg function. now run approaches testing using results data.frame constructed . ensemble p-values also show significance association spatial clustering CD4+ T cells MHCII-high status among tumor samples. ","code":"# Add the outcome back into the data results <- left_join(results,                       lung_df_tumor %>% dplyr::select(id, PID, mhcII_high) %>% distinct(),                       by = c(\"id\", \"PID\"))  # Run each ensemble test ensemble.res <- ensemble.avg(data = results, group = \"PID\",                               outcome = \"mhcII_high\", model = \"logistic\")  resample.res <- resampling.avg(data = results, group = \"PID\",                                 outcome = \"mhcII_high\", model = \"logistic\")  combo.res <- combo.weight.avg(data = results, group = \"PID\",                                outcome = \"mhcII_high\", model = \"logistic\")  # P-values ensemble.res$pval #> [1] 0.3749332 resample.res$pval #> [1] 0.5085036 combo.res$pval #> [1] 0.4716415"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/spagg/articles/spagg.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"spagg","text":"vignette, illustrate use spagg package analyze multiple spatial point patterns. particular, show use functions package construct aggregate spatial summary statistic across point patterns grouped together higher level factor, tissue sample. use aggregated spatial summary statistic predictor linear model group-level/sample-level outcome. motivation behind spagg analyses data multiplexed immunofluorescence spatial proteomics platforms may involve multiple regions--interest (ROIs) imaged tissue sample. ROI shows spatial location cells tissue can treated spatial point pattern. Access multiple ROIs per tissue sample can complicate associative analyses seeking characterize associations spatial distribution cells tissue sample-level outcomes need test association single sample-level outcome (e.g. survival case/control status) multiple spatial summary statistics. vignette use simulated spatial point pattern data. see data generated, please see spagg > data-raw > simdata.R. start loading spagg package simulated data. show first lines dataset . dataset organized mimic structure single-cell, spatial images produced multiplexed immunofluorescence spatial proteomics platforms. row corresponds detected cell, enumerated cell.id column. cells grouped together samples, denoted PID column images within samples, denoted id column. x y columns give (x,y) coordinates cell. type column denotes cell type corresponding row. simulated dataset, possible cell types b. Finally, column gives sample-level endpoint interested performing associative analyses. simulated dataset, column binary 1 0 indicator. can also plot images PID=1. plots show simulated data, illustrate common challenge arises analyzing grouped point patterns reflecting multiple ROIs tissue sample: heterogeneity spatial clustering patterns. ROI shows different clusterig pattern among b cell types. going use spatial summary statistic, Ripley’s K, characterize degree adherence clustering, repulsion, complete spatial randomness ROI. spagg package contains six approaches handling multiple spatial summary statistics associative analyses. Three approaches weighted aggregations spatial summaries using fixed weights. three ensemble approaches generate random weights used construct weighted aggregations. Within ensemble replication, test association weighted aggregation sample-level outcome. ensemble resulting p-values omnibus test. first start illustrating weighted aggregations.","code":"# Load in package library(spagg) library(ggplot2) library(cowplot) library(spatstat) #> Loading required package: spatstat.data #> Loading required package: spatstat.univar #> spatstat.univar 3.0-0 #> Loading required package: spatstat.geom #> spatstat.geom 3.3-2 #> Loading required package: spatstat.random #> spatstat.random 3.3-1 #> Loading required package: spatstat.explore #> Loading required package: nlme #> spatstat.explore 3.3-1 #> Loading required package: spatstat.model #> Loading required package: rpart #> spatstat.model 3.3-1 #> Loading required package: spatstat.linnet #> spatstat.linnet 3.2-1 #>  #> spatstat 3.1-1  #> For an introduction to spatstat, type 'beginner' library(dplyr) #>  #> Attaching package: 'dplyr' #> The following object is masked from 'package:nlme': #>  #>     collapse #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  # Load in data and show first few lines data(simdata) head(simdata) #>   PID            id         x        y cell.id type out #> 1   1 PID.1.image.1 0.4520637 98.93826       1    a   0 #> 2   1 PID.1.image.1 2.3684803 97.14292       2    a   0 #> 3   1 PID.1.image.1 7.1494031 85.91885       3    a   0 #> 4   1 PID.1.image.1 8.9429048 85.35314       4    b   0 #> 5   1 PID.1.image.1 2.0692361 89.46432       5    a   0 #> 6   1 PID.1.image.1 0.8560718 91.28216       6    b   0 # Plot the images for PID=1 --  # Save the image IDs PID.1.image.ids <- unique(simdata$id[simdata$PID == 1])  # Create a list of plots plot.list <- lapply(1:length(PID.1.image.ids), function(i) list())  # Iterate through the image IDs and create a plot for each for (id.i in PID.1.image.ids) {      pp <- simdata %>%           dplyr::filter(id == id.i) %>%           ggplot(aes(x = x, y = y, color = type)) +           geom_point() +            theme_bw() +           ggtitle(id.i)   plot.list[[which(PID.1.image.ids == id.i)]] <- pp    }  # Construct the full plot cowplot::plot_grid(plot.list[[1]], plot.list[[2]],                     plot.list[[3]], plot.list[[4]],                    plot.list[[5]], nrow = 3, ncol = 2)"},{"path":"https://sarahsamorodnitsky.github.io/spagg/articles/spagg.html","id":"weighted-aggregations","dir":"Articles","previous_headings":"","what":"Weighted Aggregations","title":"spagg","text":"first consider different approaches averaging Ripely’s K across ROIs within sample. Let’s start defining notation. Suppose sample ii RiR_i ROIs. Let nirn_{ir} number cells sample ii ROI rr. Let AirA_{ir} represent area sample ii ROI rr. Let K̂ir\\hat K_{ir} represent spatial distribution CD4+ T cells evaluate radius 3030. spagg contains implementations following three weighted averages: K‾iDiggle=1∑r=1Rinir∑r=1RinirK̂ir\\begin{equation*} \\bar K_i^{Diggle} = \\frac{1}{\\sum_{r=1}^{R_i} n_{ir}} \\sum_{r=1}^{R_i} n_{ir} \\hat K_{ir} \\end{equation*} K‾iBaddeley=1∑r=1Rinir2∑r=1Rinir2K̂ir\\begin{equation*}   \\bar K_i^{Baddeley} = \\frac{1}{\\sum_{r=1}^{R_i} n^2_{ir}} \\sum_{r=1}^{R_i} n^2_{ir} \\hat K_{ir} \\end{equation*} K‾iLandau=∑r=1RiAir∑r=1Rinir∑r=1Rinir2AirK̂ir\\begin{equation*}   \\bar K_i^{Landau} = \\frac{\\sum_{r=1}^{R_i} A_{ir}}{\\sum_{r=1}^{R_i} n_{ir}} \\sum_{r=1}^{R_i} \\frac{n^2_{ir}}{A_{ir}} \\hat K_{ir}  \\end{equation*} K‾iDiggle\\bar K_i^{Diggle} (@diggle1991analysis), K‾iBaddeley\\bar K_i^{Baddeley} (@baddeley1993analysis), K‾iLandau\\bar K_i^{Landau} (@landau2004nonparametric) proposed approaches aggregating replicated Ripley’s K statistics. first consider univariate analysis consider one cell type. start analyzing cell type associations outcomes. estimate Ripley’s K r=10r=10 ROI. Note may take several seconds (30 seconds) run. can now visualize distribution spatial summaries within image illustration variation spatial distribution cells type across ROIs.  , compute weighted averages given . also compute standard arithmetic mean comparison. , visualize spread various spatial aggregation methods within sample. samples, averages yield similar values. others, values show large variation.  now data.frame column corresponding average. can add outcome variable, , can association testing aggregated Ripley’s K statistics. like compare aggregated Ripley’s K statistics equal cases (=1) controls (=0). words, like test average spatial distribution cells across ROIs two groups. also consider bivariate analysis examine bivariate colocalization cell types b. follow similar series steps, instead use Kcross function characterize colocalization cell types. Following steps , compute averages within PID test association outcome.","code":"# Set the radius r <- 10  # Save the image IDs ids <- unique(simdata$id)  # Initialize a data.frame to store the results for each ROI cell.a.results <- simdata %>%    dplyr::select(PID, id) %>%   dplyr::distinct() %>%   dplyr::mutate(spatial = NA,                 npoints = NA,                 area = NA)   # Iterate through the ROIs (this will take a few seconds) for (i in 1:length(ids)) {     # Save the ith image  image.i <- simdata %>%    dplyr::filter(id == ids[i]) %>%    dplyr::select(x, y, type)     # Convert to a point process object    w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)    image.i.subset <- image.i %>% dplyr::filter(type == \"a\")    image.ppp <- spatstat.geom::as.ppp(image.i.subset, W = w)    marks(image.ppp) <- image.i.subset$type     # Compute Kest    Ki <- spatstat.explore::Kest(image.ppp, r = 0:r)       # Calculate the number of points    npoints.i <- spatstat.geom::npoints(image.ppp)        # Calculate the area    area.i <- spatstat.geom::area(image.ppp)       # Save the results    cell.a.results[cell.a.results$id == ids[i],]$spatial <- Ki$iso[r+1]    cell.a.results[cell.a.results$id == ids[i],]$npoints <- npoints.i    cell.a.results[cell.a.results$id == ids[i],]$area <- area.i }  # View the first few rows head(cell.a.results) #>   PID            id  spatial npoints     area #> 1   1 PID.1.image.1 702.0332     126 9024.439 #> 2   1 PID.1.image.2 314.6653     510 9841.915 #> 3   1 PID.1.image.3 622.4667     155 7771.314 #> 4   1 PID.1.image.4 636.2567     110 5619.839 #> 5   1 PID.1.image.5 525.6607     107 5185.108 #> 6   2 PID.2.image.1 632.7371     127 6941.758 # Visualize the distribution of spatial summaries within each sample cell.a.results %>%   dplyr::mutate(PID = factor(PID)) %>%   ggplot(aes(x = PID, y = spatial, group = PID)) +    geom_boxplot() +   theme_bw() +    theme(axis.text.x = element_blank(),            axis.ticks.x = element_blank()) +   ggtitle(\"Ripley's K statistics for ROIs within a each sample\") +   ylab(\"Kest\") # Compute averages cell.a.results_mean <- cell.a.results %>%     dplyr::group_by(PID) %>%     dplyr::summarise_at(dplyr::vars(spatial),                         list(~mean(.x),                               ~landau.avg(K.vec = .x, area.vec = area, n.vec = npoints),                              ~diggle.avg(K.vec = .x, n.vec = npoints),                              ~baddeley.avg(K.vec = .x, n.vec = npoints)))  # Plot the averages cell.a.results_mean %>%   tidyr::pivot_longer(2:5, names_to = \"mean\", values_to = \"value\") %>%   dplyr::mutate(mean = recode(mean,                                \"mean\" = \"Arithmetic Mean\",                               \"landau.avg\" = \"Landau Mean\",                               \"diggle.avg\" = \"Diggle Mean\",                               \"baddeley.avg\" = \"Baddeley Mean\")) %>%   dplyr::mutate(PID = factor(PID)) %>%   ggplot(aes(x = PID, y = value, group = mean, color = mean)) +   geom_point() +   theme_bw() +   ylab(\"Average Kest\") +   ggtitle(\"Averaged Ripley's K within each sample\") +   scale_color_discrete(name = \"Aggregation Method\") # First, check the ordering matches all(unique(simdata$PID) == cell.a.results_mean$PID) # TRUE! #> [1] TRUE  # Add in the outcome cell.a.results_mean$out <- simdata %>%    dplyr::select(PID, out) %>%   dplyr::distinct() %>%   dplyr::select(out) %>%   unlist()  # Test for an association between CD4 T cell spatial distributions and MHCII-high status mean.glm <- glm(out ~ mean, data = cell.a.results_mean, family = binomial()) diggle.glm <- glm(out ~ diggle.avg, data = cell.a.results_mean, family = binomial()) baddeley.glm <- glm(out ~ baddeley.avg, data = cell.a.results_mean, family = binomial()) landau.glm <- glm(out ~ landau.avg, data = cell.a.results_mean, family = binomial())  # Save the p-values in a table and display cell.a.pvals <- data.frame(   Method = c(\"Mean\", \"Diggle\", \"Baddeley\", \"Landau\"),   P.Value = c(summary(mean.glm)$coef[2,4], summary(diggle.glm)$coef[2,4],                summary(baddeley.glm)$coef[2,4], summary(landau.glm)$coef[2,4]) )  # Show the results cell.a.pvals #>     Method   P.Value #> 1     Mean 0.3149157 #> 2   Diggle 0.5042833 #> 3 Baddeley 0.5538728 #> 4   Landau 0.7870703 # Set the radius r <- 10  # Initialize a data.frame to store the results for each ROI cell.ab.results <- simdata %>%    dplyr::select(PID, id) %>%   dplyr::distinct() %>%   dplyr::mutate(spatial = NA,                 npoints = NA,                 area = NA)   # Iterate through the ROIs (this will take a few seconds) for (i in 1:length(ids)) {     # Save the ith image  image.i <- simdata %>%    dplyr::filter(id == ids[i]) %>%    dplyr::select(x, y, type)     # Convert to a point process object    w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)    image.ppp <- spatstat.geom::as.ppp(image.i, W = w)    marks(image.ppp) <- factor(image.i$type)     # Compute Kest    Ki <- spatstat.explore::Kcross(image.ppp, i = \"a\", j = \"b\", r = 0:r)       # Calculate the number of points    npoints.i <- spatstat.geom::npoints(image.ppp)        # Calculate the area    area.i <- spatstat.geom::area(image.ppp)       # Save the results    cell.ab.results[cell.ab.results$id == ids[i],]$spatial <- Ki$iso[r+1]    cell.ab.results[cell.ab.results$id == ids[i],]$npoints <- npoints.i    cell.ab.results[cell.ab.results$id == ids[i],]$area <- area.i }  # View the first few rows head(cell.ab.results) #>   PID            id  spatial npoints     area #> 1   1 PID.1.image.1 654.1854     243 9024.439 #> 2   1 PID.1.image.2 319.1038     959 9841.915 #> 3   1 PID.1.image.3 658.9129     329 7771.314 #> 4   1 PID.1.image.4 607.2475     194 5619.839 #> 5   1 PID.1.image.5 504.2842     230 5185.108 #> 6   2 PID.2.image.1 624.4899     251 6941.758 # Compute averages cell.ab.results_mean <- cell.ab.results %>%     dplyr::group_by(PID) %>%     dplyr::summarise_at(dplyr::vars(spatial),                         list(~mean(.x),                               ~landau.avg(K.vec = .x, area.vec = area, n.vec = npoints),                              ~diggle.avg(K.vec = .x, n.vec = npoints),                              ~baddeley.avg(K.vec = .x, n.vec = npoints)))  # First, check the ordering matches all(unique(simdata$PID) == cell.ab.results_mean$PID) # TRUE! #> [1] TRUE  # Add in the outcome cell.ab.results_mean$out <- simdata %>%    dplyr::select(PID, out) %>%   dplyr::distinct() %>%   dplyr::select(out) %>%   unlist()  # Test for an association between CD4 T cell spatial distributions and MHCII-high status mean.ab.glm <- glm(out ~ mean, data = cell.ab.results_mean, family = binomial()) diggle.ab.glm <- glm(out ~ diggle.avg, data = cell.ab.results_mean, family = binomial()) baddeley.ab.glm <- glm(out ~ baddeley.avg, data = cell.ab.results_mean, family = binomial()) landau.ab.glm <- glm(out ~ landau.avg, data = cell.ab.results_mean, family = binomial())  # Save the p-values in a table and display cell.ab.pvals <- data.frame(   Method = c(\"Mean\", \"Diggle\", \"Baddeley\", \"Landau\"),   P.Value = c(summary(mean.ab.glm)$coef[2,4], summary(diggle.ab.glm)$coef[2,4],                summary(baddeley.ab.glm)$coef[2,4], summary(baddeley.ab.glm)$coef[2,4]) )  # Show the results cell.ab.pvals #>     Method   P.Value #> 1     Mean 0.3954213 #> 2   Diggle 0.4954686 #> 3 Baddeley 0.5378123 #> 4   Landau 0.5378123"},{"path":"https://sarahsamorodnitsky.github.io/spagg/articles/spagg.html","id":"ensemble-approaches","dir":"Articles","previous_headings":"","what":"Ensemble Approaches","title":"spagg","text":"now illustrate using ensemble testing test hypothesis. ensemble approaches consider multiple random weights used construct aggregations spatial summary statistics. set random weights, test association weighted aggregation outcome. repeat many random weights combine resulting p-values using p-value combination method. purpose, use Cauchy combination test @liu2020cauchy. motivation behind ensemble approaches best set weights (weights yield highest power) generally unknown outset. reason, considering many different possible weights may gain us power may capture true relationship aggregated spatial summary statistics sample-level outcome. spagg contains implementations three different approaches: Standard ensemble testing: approach, spagg randomly generates weights standard normal distribution used construct weighted mean Ripley’s K estimates obtained ROI. process repeated many times. random set weights, association weighted mean spatial summary sample-level outcomes tested. resulting p-values combined using Cauchy combination test. approach contained ensemble.avg function. Resampling: approach, spagg randomly samples one spatial summary statisti per sample tests association sample-level outcome. process repeated many times resulting p-values combined using Cauchy combination test. approach contained resampling.avg function. Combination testing: approach, spagg randomly generates weights standard normal distribution uses weights well number cells ROI construct weighted mean Ripley’s K estimates. process repeated many times resulting p-values combined using Cauchy combination test. approach contained combo.weight.avg function. now run approaches testing univariate analysis using cell..results data.frame constructed . can also perform ensemble testing bivariate case. show using cell.ab.results object.","code":"# Add the outcome back into the data cell.a.results <- left_join(cell.a.results,                       simdata %>% dplyr::select(id, PID, out) %>% distinct(),                       by = c(\"id\", \"PID\"))  # Run each ensemble test ensemble.res <- ensemble.avg(data = cell.a.results, group = \"PID\",                               outcome = \"out\", model = \"logistic\")  resample.res <- resampling.avg(data = cell.a.results, group = \"PID\",                                 outcome = \"out\", model = \"logistic\")  combo.res <- combo.weight.avg(data = cell.a.results, group = \"PID\",                                outcome = \"out\", model = \"logistic\")  # Add the p-values to the results above cell.a.pvals <- rbind.data.frame(   cell.a.pvals,   data.frame(     Method = c(\"Ensemble\", \"Resampling\", \"Combo\"),     P.Value = c(ensemble.res$pval, resample.res$pval, combo.res$pval)   ) )  # Print the results cell.a.pvals #>       Method   P.Value #> 1       Mean 0.3149157 #> 2     Diggle 0.5042833 #> 3   Baddeley 0.5538728 #> 4     Landau 0.7870703 #> 5   Ensemble 0.3251936 #> 6 Resampling 0.9309895 #> 7      Combo 0.8380127 # Add the outcome back into the data cell.ab.results <- left_join(cell.ab.results,                       simdata %>% dplyr::select(id, PID, out) %>% distinct(),                       by = c(\"id\", \"PID\"))  # Run each ensemble test ensemble.res <- ensemble.avg(data = cell.ab.results, group = \"PID\",                               outcome = \"out\", model = \"logistic\")  resample.res <- resampling.avg(data = cell.ab.results, group = \"PID\",                                 outcome = \"out\", model = \"logistic\")  combo.res <- combo.weight.avg(data = cell.ab.results, group = \"PID\",                                outcome = \"out\", model = \"logistic\")  # Add the p-values to the results above cell.ab.pvals <- rbind.data.frame(   cell.ab.pvals,   data.frame(     Method = c(\"Ensemble\", \"Resampling\", \"Combo\"),     P.Value = c(ensemble.res$pval, resample.res$pval, combo.res$pval)   ) )  # Print the results cell.ab.pvals #>       Method   P.Value #> 1       Mean 0.3954213 #> 2     Diggle 0.4954686 #> 3   Baddeley 0.5378123 #> 4     Landau 0.5378123 #> 5   Ensemble 0.4322548 #> 6 Resampling 0.8006880 #> 7      Combo 0.8496178"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/spagg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sarah Samorodnitsky. Maintainer.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Samorodnitsky S (2024). spagg: Aggregation approaches combining spatial summary statistics. R package version 0.1.0, https://sarahsamorodnitsky.github.io/spagg/.","code":"@Manual{,   title = {spagg: Aggregation approaches for combining spatial summary statistics},   author = {Sarah Samorodnitsky},   year = {2024},   note = {R package version 0.1.0},   url = {https://sarahsamorodnitsky.github.io/spagg/}, }"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/spagg/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregation approaches for combining spatial summary statistics","text":"goal spagg provide tools aggregating spatial summary statistics generated multiple regions--interest (ROIs) collected tissue sample using multiplexed spatial proteomics technologies. analysis spatial proteomics often involves calculating spatial summary statistic, Ripley’s K, quantify level clustering, repulsion, complete spatial randomness exhibited cells. Given multiple ROIs sample, aggregating spatial summary statistics ROI single value can facilitate downstream association testing clinical outcomes. spagg provides several methods aggregating spatial summary statistics. include three weighted means (diggle.avg, baddeley.avg, landau.avg) three ensemble approaches (ensemble.avg, resampling.avg, combo.weight.avg). weighted means aggregate summary statistics using weighted mean based number cells ROI /area ROI. ensemble approaches use random weights construct aggregation combine resulting p-values across many randomly-generated weights ensemble test. weighted means can easily incorporated analytical approaches spatial proteomics, SPatial Omnibus Test (SPOT). Incorporation ensemble approaches SPOT development.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregation approaches for combining spatial summary statistics","text":"can install development version spagg GitHub : spagg relies several required dependencies: ACAT, dplyr, magrittr, spatstat family packages, stats, survival, tidyselect. ACAT package currently development Github. properly install spagg, latest version devtools required ensure can install ACAT Github. addition, spagg relies several suggested packages run vignettes: knitr, rmarkdown, ggplot2, tidyr, spatstat.utils, spatstat.univar, SPOT.","code":"# First, install devtools if (!require(\"devtools\", quietly = TRUE)) {   install.packages(\"devtools\") }  # Install from Github devtools::install_github(\"sarahsamorodnitsky/spagg\")"},{"path":"https://sarahsamorodnitsky.github.io/spagg/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Aggregation approaches for combining spatial summary statistics","text":"example usage spagg single-cell spatial proteomics imaging analysis, please see associated vignettes. vignettes illustrate apply weighted means ensemble approaches analyses real multiplexed spatial proteomics datasets.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/index.html","id":"bugs-and-improvements","dir":"","previous_headings":"","what":"Bugs and Improvements","title":"Aggregation approaches for combining spatial summary statistics","text":"Please feel free use Issues tab note bugs suggest improvements.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"Compute aggregation Ripley's K based Baddeley et al. (1993)","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"","code":"baddeley.avg(K.vec, n.vec)"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"K.vec Vector Ripley's K estimates across series images n.vec Vector number points image","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"Returns weighted average Ripley's K values based number points image","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"Baddeley et al. (1993). Analysis Three-Dimensional Point Pattern Replication. Journal Royal Statistical Society. Series C (Applied Statistics), 42(4), 641-668.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/baddeley.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute aggregation of Ripley's K based on Baddeley et al. (1993) — baddeley.avg","text":"","code":"# Generate simulated Ripley's K values, areas, and number of points K.vec <- rnorm(3, mean = 1000, sd = 100) n.vec <- rnorm(3, mean = 300, sd = 50)  # Compute a weighted average baddeley.avg(K.vec, n.vec) #> [1] 874.9542"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/combo.weight.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","text":"Ensemble aggregation spatial summaries (e.g. Ripley's K) using combination random weighting weighting number points","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/combo.weight.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","text":"","code":"combo.weight.avg(   data,   group,   outcome,   cens = NULL,   model = \"survival\",   adjustments = NULL,   n.ensemble = 1000,   seed = NULL )"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/combo.weight.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","text":"data data.frame tibble containing data, including patient IDs, image IDs, outcomes, spatial summaries. group Grouping variable images, e.g. patient IDs. outcome Column name outcome data. cens Column name event indicator column. using survival outcome, leave NULL. model Model type. Options \"logistic\" logistic regression \"survival\" Cox proportional hazards model. adjustments Column names columns data adjust ensemble replication n.ensemble many ensemble replications done? Default 1000. seed seed reproducible results. left NULL, funciton generate seed return .","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/combo.weight.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","text":"list length 2 containing overall p-value obtained using Cauchy combination test (`pval`) seed used reproducibility (`seed`). user provided seed, `seed` match given. Otherwise, function randomly selects seed returned.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/combo.weight.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using a combination of random weighting and weighting by the number of points — combo.weight.avg","text":"","code":"# Pick a radius to evaluate Ripley's K r <- 30  # Save the image IDs ids <- unique(simdata$id)  # Compute Ripley's K for tumor cells at r K.vec <- c() npoints.vec <- c() for (i in 1:length(ids)) {   # Save the ith image   image.i <- simdata %>%     dplyr::filter(id == ids[i]) %>%     dplyr::select(x,y,type)    # Convert to a point process object   w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)  image.i.subset <- image.i %>% dplyr::filter(type == \"a\")  image.ppp <- spatstat.geom::as.ppp(image.i.subset, W = w)    # Compute Kest   Ki <- spatstat.explore::Kest(image.ppp, r = 0:30)    # Calculate the number of points   npoints.vec[i] <- spatstat.geom::npoints(image.ppp)    # Save the result   K.vec[i] <- Ki$iso[31] }  data.subset <- simdata %>%   dplyr::select(tidyselect::all_of(c(\"id\", \"PID\", \"out\"))) %>%   dplyr::distinct()  data.subset$spatial <- K.vec data.subset$npoints <- npoints.vec  # Remove NaNs data.subset <- data.subset %>% dplyr::filter(!is.na(spatial))  # Test combo.weight.avg(data = data.subset, group = \"PID\", outcome = \"out\", model = \"logistic\") #> $pval #> [1] 0.8581186 #>  #> $seed #> [1] 147083781 #>"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"Compute aggregation Ripley's K based Diggle et al. (1991)","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"","code":"diggle.avg(K.vec, n.vec)"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"K.vec Vector Ripley's K estimates across series images n.vec Vector number points image","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"Returns weighted average Ripley's K values based number points image","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"Diggle et al. (1991). Analysis Variance Replicated Spatial Point Patterns Clinical Neuroanatomy. Journal American Statistical Association, 86(415), 618-625.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/diggle.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute aggregation of Ripley's K based on Diggle et al. (1991) — diggle.avg","text":"","code":"# Generate simulated Ripley's K values, areas, and number of points K.vec <- rnorm(3, mean = 1000, sd = 100) n.vec <- rnorm(3, mean = 300, sd = 50)  # Compute a weighted average diggle.avg(K.vec, n.vec) #> [1] 921.2886"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"Ensemble aggregation spatial summaries (e.g. Ripley's K) using random weighting","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"","code":"ensemble.avg(   data,   group,   outcome,   cens = NULL,   model = \"survival\",   adjustments = NULL,   n.ensemble = 1000,   seed = NULL )"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"data data.frame tibble containing data, including patient IDs, image IDs, outcomes, spatial summaries. group Grouping variable images, e.g. patient IDs. outcome Column name outcome data. cens Column name event indicator column. using survival outcome, leave NULL. model Model type. Options \"logistic\" logistic regression \"survival\" Cox proportional hazards model. adjustments Column names columns data adjust ensemble replication n.ensemble many ensemble replications done? Default 1000. seed seed reproducible results. left NULL, funciton generate seed return .","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"list length 2 containing overall p-value obtained using Cauchy combination test (`pval`) seed used reproducibility (`seed`). user provided seed, `seed` match given. Otherwise, function randomly selects seed returned.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"Liu et al. (2023) Ensemble methods testing global null. Journal Royal Statistical Society Series B: Statistical Methodology. 00. 1-26.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/ensemble.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) using random weighting — ensemble.avg","text":"","code":"# Pick a radius to evaluate Ripley's K r <- 30  # Save the image IDs ids <- unique(simdata$id)  # Compute Ripley's K for tumor cells at r K.vec <- c() for (i in 1:length(ids)) {  # Save the ith image  image.i <- simdata %>%    dplyr::filter(id == ids[i]) %>%    dplyr::select(x,y,type)   # Convert to a point process object  w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)  image.i.subset <- image.i %>% dplyr::filter(type == \"a\")  image.ppp <- spatstat.geom::as.ppp(image.i.subset, W = w)   # Compute Kest  Ki <- spatstat.explore::Kest(image.ppp, r = 0:30)   # Save the result  K.vec[i] <- Ki$iso[31] }  data.subset <- simdata %>%  dplyr::select(tidyselect::all_of(c(\"id\", \"PID\", \"out\"))) %>%  dplyr::distinct()  data.subset$spatial <- K.vec  # Remove NaNs data.subset <- data.subset %>% dplyr::filter(!is.na(spatial))  # Test ensemble.avg(data = data.subset, group = \"PID\", outcome = \"out\", model = \"logistic\") #> $pval #> [1] 0.9206109 #>  #> $seed #> [1] 1203513063 #>"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"Compute aggregation Ripley's K based Landau et al. (2004)","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"","code":"landau.avg(K.vec, area.vec, n.vec)"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"K.vec Vector Ripley's K estimates across series images area.vec Vector sizes window image n.vec Vector number points image","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"Returns weighted average Ripley's K values based sizes images numbers points","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"Landau et al. (2004) Nonparametric One-way Analysis Variance Replicated Bivariate Spatial Point Patterns. Biometrical Journal, 46(1), 19-34.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/landau.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute aggregation of Ripley's K based on Landau et al. (2004) — landau.avg","text":"","code":"# Generate simulated Ripley's K values, areas, and number of points K.vec <- rnorm(3, mean = 1000, sd = 100) area.vec <- rnorm(3, mean = 20000, sd = 100) n.vec <- rnorm(3, mean = 300, sd = 50)  # Compute a weighted average landau.avg(K.vec, area.vec, n.vec) #> [1] 1025.426"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/resampling.avg.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","text":"Ensemble aggregation spatial summaries (e.g. Ripley's K) via resampling","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/resampling.avg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","text":"","code":"resampling.avg(   data,   group,   outcome,   cens = NULL,   model = \"survival\",   adjustments = NULL,   n.resample = 1000,   seed = NULL )"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/resampling.avg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","text":"data data.frame tibble containing data, including patient IDs, image IDs, outcomes, spatial summaries. group Grouping variable images, e.g. patient IDs. outcome Column name outcome data. cens Column name event indicator column. using survival outcome, leave NULL. model Model type. Options \"logistic\" logistic regression \"survival\" Cox proportional hazards model. adjustments Column names columns data adjust ensemble replication n.resample many resample replications done? Default 1000. seed seed reproducible results. left NULL, funciton generate seed return .","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/resampling.avg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","text":"list length 2 containing overall p-value obtained using Cauchy combination test (`pval`) seed used reproducibility (`seed`). user provided seed, `seed` match given. Otherwise, function randomly selects seed returned.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/resampling.avg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensemble aggregation of spatial summaries (e.g. Ripley's K) via resampling — resampling.avg","text":"","code":"# Pick a radius to evaluate Ripley's K r <- 30  # Save the image IDs ids <- unique(simdata$id)  # Compute Ripley's K for tumor cells at r K.vec <- c() for (i in 1:length(ids)) {  # Save the ith image  image.i <- simdata %>%    dplyr::filter(id == ids[i]) %>%    dplyr::select(x,y,type)   # Convert to a point process object  w <- spatstat.geom::convexhull.xy(image.i$x, image.i$y)  image.i.subset <- image.i %>% dplyr::filter(type == \"a\")  image.ppp <- spatstat.geom::as.ppp(image.i.subset, W = w)   # Compute Kest  Ki <- spatstat.explore::Kest(image.ppp, r = 0:30)   # Save the result  K.vec[i] <- Ki$iso[31] }  data.subset <- simdata %>%  dplyr::select(tidyselect::all_of(c(\"id\", \"PID\", \"out\"))) %>%  dplyr::distinct()  data.subset$spatial <- K.vec  # Remove NaNs data.subset <- data.subset %>% dplyr::filter(!is.na(spatial))  # Test resampling.avg(data = data.subset, group = \"PID\", outcome = \"out\", model = \"logistic\") #> $pval #> [1] 0.9879644 #>  #> $seed #> [1] 478785140 #>"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/simdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated point pattern dataset for examples — simdata","title":"Simulated point pattern dataset for examples — simdata","text":"randomly-generated dataset purpose illustrating usage functions contained package. See spagg/data-raw/simdata.R code simulate dataset.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/simdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated point pattern dataset for examples — simdata","text":"","code":"simdata"},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/simdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated point pattern dataset for examples — simdata","text":"## `simdata` data frame 38515 rows 6 columns PID Sample ID groups regions--interest (ROI) together id ROI ID. corresponds image within larger sample cell.id Enumerates cell within ROI. row corresponds cell. x x-coordinate cell within ROI y y-coordinate cell within ROI type Cell-type label. Options '' 'b'. randomly generated. Sample-level binary outcome. Note within PID.","code":""},{"path":"https://sarahsamorodnitsky.github.io/spagg/reference/spagg-package.html","id":null,"dir":"Reference","previous_headings":"","what":"spagg: Aggregation approaches for combining spatial summary statistics — spagg-package","title":"spagg: Aggregation approaches for combining spatial summary statistics — spagg-package","text":"Implements six aggregation approaches combining spatial summary statistics estimated multiple multiplexed spatial proteomics images samples collected location person.","code":""},{"path":[]}]
